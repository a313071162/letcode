# letcode
these are some examples.


- 201 注意奇偶相与一定为偶数，如果为连续的数字，则奇数可不用考虑
- 49 此题比较简单，主要是需要掌握字符串排序，并且字典的key值可以为元组
- 56 双向实现，从正反两方面都可以考虑
- 459 代码很简单（最简单的方法是通过枚举来实现），但是自己没想到，要想知道是否有子串，可选择将两个s连在一起，移除第一个和最后一个字符，如果还能找到s，则证明其一定包含子串
- 491 递归和动态规划是我的一难点，看了别人的代码感觉会，自己写又弄不出来。在递归和动态规划一定要注意重复的问题
- 17 此题不是很难，其应属于回溯算法中较简单的一类，需提前定义数字含有的字母，且在遍历时，应该在迭代处进行字符串增加
- 332 看题解时，发现一个欧拉回路的问题（简单说一下就是从一个点出发会形成一个回路），此处可通过压栈出栈的方法来达到简单求解
- 657 这道题很简单，只需要想清楚正负相互抵消的原则
- 557 这道题很简单，理解清楚python内核函数就很容易了
- 166 这道题很绕，首先要判断乘除法相同为正，相异为负，其次就是需要记住开始循环的位置
- 841 两种方法，一种是使用dfs深度优先遍历实现，另一种方法是使用排除法进行遍历实现的，若进入过该房间，就将其设置为True，如果全都为True，则证明都进入过
- 1455 需要比对搜索字符是否为前缀
- 725 对链表的操作不是很熟悉，同时，在分割链表的时候，需要对后面的范围进行遍历
- 486 感觉这道题就是一个动态规划，找最大的组合，每个玩家都贪心选择最大的值，从这道题看出动态规划问题，自己真的还是写不来代码
- 51 之前很久没做题了，其就是被这道题打击到了，想法是对的，但是就是不知道为啥写不对，感觉很难受呀
- 637 今天做了这棵树，足以看出自己的基础多么的薄弱，明明很简单的问题，想了很久也没有答案
- 79 这道深度优先是自己没有遇到过的题目，其主要有两个经典之处，第一个是通过visited来判断是否访问，第二个是一个回退机制，如果当前值不可行可回退到最初状态